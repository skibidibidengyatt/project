<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>УП05. Разработка модели архитектуры информационной системы для интернет-магазина</title>
</head>
<body>
<h1>УП05. Разработка модели архитектуры информационной системы для интернет-магазина</h1>
<h2>1. Введение и Цели Архитектуры</h2>
<p><b>Цель:</b> Спроектировать масштабируемую, отказоустойчивую и безопасную архитектуру информационной системы интернет-магазина, которая эффективно поддерживает бизнес-процессы компании.</p>
<p><b>Ключевые архитектурные требования:</b></p>
<ul>
    <li><b>Производительность:</b> Быстрое время отклика (<200 мс) для ключевых операций (просмотр каталога, поиск, добавление в корзину).</li>
    <li><b>Масштабируемость:</b> Возможность горизонтального масштабирования для обработки пиковых нагрузок (например, во время распродаж).</li>
    <li><b>Надежность:</b> Минимизация времени простоя (целевой показатель доступности 99.9%).</li>
    <li><b>Безопасность:</b> Защита конфиденциальных данных пользователей (PII) и платежной информации (PCI DSS).</li>
    <li><b>Поддерживаемость:</b> Модульность системы для удобства разработки и внесения изменений.</li>
</ul>

<h2>2. Высокоуровневая архитектура (Logical View)</h2>
<p>Система будет построена по многоуровневой (N-tier) архитектуре с четким разделением ответственности.</p>
<img src="task6-1.png"/>

<h2>3. Детализация компонентов и моделей</h2>
<h3>3.1. Клиентский Уровень (Frontend)</h3>
<ul>
    <li><b>Модель:</b> Single Page Application (SPA) на React.js.</li>
    <li><b>Компоненты:</b></li>
    <ul>
        <li>ProductCatalog: Компонент для отображения и фильтрации товаров.</li>
        <li>ShoppingCart: Управление корзиной.</li>
        <li>CheckoutWizard: Процесс оформления заказа.</li>
        <li>UserProfile: Личный кабинет пользователя.</li>
    </ul>
    <li><b>Взаимодействие:</b> Общается с бэкендом исключительно через REST API и WebSocket (для уведомлений).</li>
</ul>
<h3>3.2. Уровень представления (API Gateway)</h3>
<ul>
    <li><b>Модель:</b> Единая точка входа (например, на основе Nginx или специалированного решения как AWS API Gateway).</li>
    <li>Функции:</li>
    <ul>
        <li><b>Маршрутизация запросов</b> к соответствующим бэкенд-сервисам.</li>
        <li><b>Аутентификация и авторизация</b> (проверка JWT-токенов).</li>
        <li><b>Кэширование </b>часто запрашиваемых данных (например, статический контент).</li>
        <li><b>Rate Limiting</b> для защиты от DDoS-атак и злоупотреблений.</li>
        <li><b>Логирование</b> входящих запросов.</li>
    </ul>
</ul>
<h3>3.3. Бизнес-уровень (Backend Services - Микросервисная архитектура)</h3>
<p>Система декомпозирована на набор слабосвязанных сервисов. Каждый сервис управляет своей собственной моделью данных.</p>
<ul>
    <li><b>Сервис Пользователей (User Service)</b></li>
    <ul>
        <li><b>Модель данных:</b> User, Profile, Address.</li>
        <li><b>Ответственность:</b> Регистрация, аутентификация, управление профилем, ACL (Access Control List).</li>
        <li><b>API:</b> POST /auth/login, GET /users/me, PUT /users/address.</li>
    </ul>
    <li><b>Сервис Каталога (Catalog Service)</b></li>
    <ul>
        <li>Модель данных: Product, Category, Inventory, Review.</li>
        <li><b>Ответственность:</b> Управление товарами, категориями, остатками, отзывами.</li>
        <li><b>API:</b> GET /products, GET /products/{id}, GET /categories.</li>
        <li><b>Связь:</b> Обновляет данные в Elasticsearch при изменении товара (асинхронно).</li>
    </ul>
    <li><b>Сервис Поиска (Search Service)</b></li>
    <ul>
        <li><b>Модель данных:</b> Индекс в Elasticsearch на основе данных из Catalog Service.</li>
        <li><b>Ответственность:</b> Полнотекстовый поиск, фасетная навигация, фильтрация.</li>
        <li><b>API:</b> GET /search?q=query&filters=....</li>
    </ul>
    <li><b>Сервис Корзины (Cart Service)</b></li>
    <ul>
        <li><b>Модель данных:</b> Cart, CartItem.</li>
        <li><b>Ответственность:</b> Управление корзиной покупок.</li>
        <li><b>Хранилище:</b> Redis (для высокой производительности и временного хранения).</li>
        <li><b>API:</b> POST /cart/items, GET /cart, DELETE /cart/items/{id}.</li>
    </ul>
    <li><b>Сервис Заказов (Order Service)</b></li>
    <ul>
        <li><b>Модель данных:</b> Order, OrderItem.</li>
        <li><b>Ответственность:</b> Процесс оформления заказа (Checkout), управление статусами заказов.</li>
        <li><b>Связь:</b> Синхронно взаимодействует с Payment Service и асинхронно с Notification Service и Inventory Service (для резервирования товара).</li>
    </ul>
    <li><b>Сервис Платежей (Payment Service)</b></li>
    <ul>
        <li><b>Модель данных:</b> Payment, Transaction.</li>
        <li><b>Ответственность:</b> Интеграция с внешними платежными шлюзами (Stripe, CloudPayments и т.д.).</li>
        <li><b>Связь:</b> Принимает запрос на списание средств от Order Service, возвращает результат.</li>
    </ul>
    <li><b>Сервис Уведомлений (Notification Service)</b></li>
    <ul>
        <li><b>Модель данных:</b> EmailTemplate, SMS.</li>
        <li><b>Ответственность:</b> Отправка email (подтверждение заказа, сброс пароля) и SMS через очереди сообщений (RabbitMQ/Celery).</li>
        <li><b>Модель взаимодействия:</b> Асинхронная, через брокер сообщений.</li>
    </ul>
</ul>
<h3>3.4. Уровень данных (Data Layer)</h3>
<ul>
    <li><b>PostgreSQL:</b> Основное реляционное хранилище для структурированных данных (пользователи, заказы, товары). Выбор обоснован надежностью и поддержкой транзакций.</li>
    <li><b>Elasticsearch:</b> Специализированное хранилище для поиска и фильтрации по каталогу товаров.</li>
    <li><b>Redis:</b></li>
    <ul>
        <li>Кэширование результатов запросов к каталогу и пользователям.</li>
        <li>Хранение сессий и корзин.</li>
        <li>Брокер сообщений для фоновых задач (в связке с Celery).</li>
    </ul>
    <li><b>Объектное хранилище (S3-совместимое):</b> Хранение изображений товаров, статических файлов.</li>
</ul>

<h2>4. Модель данных (Высокоуровневая ER-диаграмма)</h2>
<img src="task6-2.png"/>
<h3>Ключевые сущности:</h3>
<ul>
    <li><b>User:</b> id, email, password_hash, created_at</li>
    <li><b>Product:</b> id, name, description, price, sku, category_id</li>
    <li><b>Order:</b> id, user_id, status, total_amount, created_at</li>
    <li><b>OrderItem:</b> id, order_id, product_id, quantity, price</li>
    <li><b>Category:</b> id, name, slug, parent_id</li>
</ul>

<h2>5. Модель развертывания (Deployment View)</h2>
<ul>
    <li><b>Контейнеризация:</b> Все сервисы упакованы в Docker-контейнеры.</li>
    <li><b>Оркестрация:</b> Используется <b>Kubernetes (k8s)</b> или <b>Docker Swarm</b> для автоматического развертывания, масштабирования и управления контейнерами.</li>
    <li><b>Балансировщик нагрузки:</b> <b>Nginx Ingress Controller</b> в k8s или <b>AWS Application Load Balancer</b> для распределения входящего трафика.</li>
    <li><b>CI/CD:</b> Автоматизированный пайплайн (например, GitLab CI/CD) для сборки, тестирования и развертывания.</li>
</ul>

<h2>6. Обоснование ключевых архитектурных решений</h2>
<ul>
    <li><b>Микросервисы против Монолита:</b> Выбор в пользу микросервисов обоснован необходимостью независимого масштабирования (например, сервис поиска нагружен больше, чем сервис пользователей) и независимыми циклами разработки.</li>
    <li><b>Асинхронная коммуникация:</b> Использование брокера сообщений (Redis/RabbitMQ) для уведомлений и тяжелых задач развязывает сервисы и повышает отказоустойчивость. Если сервис уведомлений временно недоступен, заказы все равно могут создаваться.</li>
    <li><b>Разделение БД для чтения и записи (CQRS):</b> Каталог оптимизирован для чтения через Elasticsearch, в то время как основная база (PostgreSQL) служит источником истины для операций записи. Это значительно повышает производительность поиска.</li>
    <li><b>Кэширование на всех уровнях:</b> Redis (кэш сессий и корзин), кэш в API Gateway (статика), кэш на фронтенде (CDN для изображений) — все это снижает нагрузку на бэкенд и БД.</li>
</ul>

<h2>Заключение</h2>
<p>Предложенная модель архитектуры представляет собой современное, robust-решение для интернет-магазина. Она построена на принципах микросервисной архитектуры, что обеспечивает высокую степень масштабируемости, отказоустойчивости и поддерживаемости. Четкое разделение на уровни и сервисы позволяет командам разработки работать параллельно и безопасно вносить изменения в отдельные части системы, не затрагивая ее целиком.</p>


</body>
</html>